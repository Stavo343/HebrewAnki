@page "/"
@using AnkiNet
@using HebrewAnki.Console
@using HebrewAnki.Console.Enums
@using HebrewAnki.Data.XmlParsers
@inject IJSRuntime JS

<PageTitle>Anki Deck Generator</PageTitle>

<span>@_errorMessage</span>
<br />

@switch (_homeView)
{
    case HomeView.FreshNav:
        {
            <div>Do you have a .apkg file already you would like to update?</div>
            <MudButton @onclick="ReadyToUpload">Yes</MudButton>
            <MudButton @onclick="@ReadyToSelect">No</MudButton>
        }
        break;
    case HomeView.ReadyToUpload:
        {
            <InputFile OnChange="LoadFile" accept=".apkg" />
        }
        break;
    case HomeView.Selection:
        {
            <style>
                .mud-table-cell-custom-group {
                    font-weight: 500;
                    width: 95%;
                }

                .mud-table-cell-custom-group-footer {
                    padding-bottom: 50px;
                    text-align: right;
                }
            </style>

            <MudTable @ref="_mudTable "Hover="true" Breakpoint="Breakpoint.Sm"
                      Items="@GetSelectableChapters()"
                      Virtualize="false"
                      GroupBy="@_groupDefinition"
                      GroupHeaderStyle="background-color:var(--mud-palette-background-gray)"
                      Dense="true"
                      MultiSelection="true">
                <ColGroup>
                    <col style="width: 60px;" />
                    <col style="width: 60px;" />
                </ColGroup>
                <HeaderContent>
                    <MudTh style="width: 60px;"></MudTh>
                </HeaderContent>
                <GroupHeaderTemplate>
                    <MudTh Class="mud-table-cell-custom-group">@(context.Key)</MudTh>
                </GroupHeaderTemplate>
                <RowTemplate>
                    <MudTd>@context.ChapterNumber</MudTd>
                </RowTemplate>
            </MudTable>
            
            <MudButton @onclick="GenerateDeck">Generate Deck</MudButton>
        }
        break;
    case HomeView.GeneratingDeck:
        {
            <div>
                @foreach(var log in Logs)
                {
                    @log
                    <br />
                }
            </div>
        }
        break;
    case HomeView.DownloadDeck:
        {
            <MudButton @onclick="DownloadFileFromStream" >
                Download New Collection
            </MudButton>
        }
        break;
}

<script>
    window.downloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
    }
</script>

@code {
    private HomeView _homeView = HomeView.FreshNav;
    private string? _errorMessage;
    private List<string> Logs { get; } = new();

    private List<Chapter> _chaptersToSkip = new();
    private MudTable<Chapter> _mudTable;
    private TableGroupDefinition<Chapter> _groupDefinition = new()
    {
        Indentation = true,
        Expandable = true,
        IsInitiallyExpanded = false,
        Selector = (e) => e.Book
    };

    private byte[] _newCollectionFile = [0];
    
    private void Log(string log)
    {
        Logs.Insert(0, $"{DateTime.Now}: {log}");
        StateHasChanged();
    }

    private void ClearLogs()
    {
        Logs.RemoveAll(x => true);
    }
    
    private async Task LoadFile(InputFileChangeEventArgs e)
    {
        AnkiCollection uploadedAnkiCollection = null;
        
        try
        {
            using MemoryStream ms = new MemoryStream();
            await e.File.OpenReadStream(200000000000).CopyToAsync(ms);
            uploadedAnkiCollection = await AnkiFileReader.ReadFromStreamAsync(ms);
        }
        catch (Exception ex)
        {
            _errorMessage = "Something went wrong with reading the .apkg file.";
        }
        
        SetChaptersToSkip(uploadedAnkiCollection);

        _homeView = HomeView.Selection;
    }

    private void SetChaptersToSkip(AnkiCollection uploadedCollection)
    {
        foreach (var deck in uploadedCollection.Decks)
        {
            if (deck.Name == "Default")
                continue;
            
            var deckScope = Int32.TryParse(deck.Name.Last().ToString(), out int unused)
                ? DeckScope.Chapter
                : DeckScope.Book;
            
            var bookName = deck.Name.Substring(deck.Name.IndexOf("::") + 2);
            if (deckScope == DeckScope.Chapter)
                bookName = bookName.Substring(0, bookName.IndexOf("::"));

            if (deckScope == DeckScope.Chapter)
            {
                var chapterNumber = deck.Name.Substring(
                    deck.Name.LastIndexOf(" ") + 1,
                    deck.Name.Length - deck.Name.LastIndexOf(" ") - 1);
                
                _chaptersToSkip.Add(new()
                {
                    Book = bookName,
                    ChapterNumber = Int32.Parse(chapterNumber)
                });
            }
            else
            {
                for (var i = 1; i < BookData.ChaptersPerBook[bookName] + 1; i++)
                    _chaptersToSkip.Add(new()
                    {
                        Book = bookName,
                        ChapterNumber = i
                    });
            }
        }
    }

    private List<Chapter> GetSelectableChapters()
    {
        return BookData.GetAllChapters()
            .Where(x => !_chaptersToSkip.Any(s => s.Book == x.Book && s.ChapterNumber == x.ChapterNumber))
            .ToList();
    }

    private void ReadyToUpload()
    {
        _homeView = HomeView.ReadyToUpload;
    }

    private void ReadyToSelect()
    {
        _homeView = HomeView.Selection;
    }

    private async Task GenerateDeck()
    {
        if (!_mudTable.SelectedItems?.Any() ?? false)
        {
            _errorMessage = "No chapters were selected.";
            return;
        }

        _errorMessage = null;
        
        var selectedChapters = _mudTable.SelectedItems!.ToList();
        _homeView = HomeView.GeneratingDeck;
        StateHasChanged();
        await Task.Yield();
        
        ClearLogs();
        var deckBuilderOptions = new DeckBuilderOptions();
        Log("Parsing the lexical index");
        deckBuilderOptions.LexicalIndexEntries = LexicalIndexParser.ParseLexicalIndex("../HebrewAnki.Data/lexicon/LexicalIndex.xml");
        Log("Parsing the BDB");
        deckBuilderOptions.BdbEntries = BdbParser.ParseBdb("../HebrewAnki.Data/lexicon/bdb.xml");
        Log("Parsing the WLC text");
        deckBuilderOptions.WlcBooks = WlcParser.ParseWlcBooks("../HebrewAnki.Data/wlc/");
        Log("Parsing the OHSM entries");
        deckBuilderOptions.OshmEntries = OshmParser.ParseOshmEntries("../HebrewAnki.Data/lexicon/Oshm.xml");
        deckBuilderOptions.GlobalDeckNamePrefix = "12/18/24: Hebrew/Aramaic Vocab";
        
        var deckScope = DeckScope.Chapter;
        Log("Creating notes/cards for your selected chapters. This may take a while...");
        var decks = new DeckBuilder(Log, deckBuilderOptions).Build(selectedChapters, _chaptersToSkip, deckScope);
        var newCollection = CollectionBuilder.Build(decks);

        Log("Creating the download file");
        using MemoryStream ms = new MemoryStream();
        await AnkiFileWriter.WriteToStreamAsync(ms, newCollection);
        _newCollectionFile = ms.ToArray();
        
        _homeView = HomeView.DownloadDeck;
        StateHasChanged();
    }

    private async Task DownloadFileFromStream()
    {
        using var stream = new MemoryStream(_newCollectionFile);
        var fileName = $"12/18/24: Hebrew/Aramaic Vocab - {DateTime.Now}.apkg";

        using var streamRef = new DotNetStreamReference(stream: stream);

        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }
}