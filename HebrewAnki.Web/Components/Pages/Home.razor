@page "/"
@using System.Text
@using System.Text.Json
@using AnkiNet
@using HebrewAnki.Console
@using HebrewAnki.Console.Enums
@using HebrewAnki.Data
@using HebrewAnki.Data.Models
@using HebrewAnki.Data.XmlParsers
@inject IJSRuntime JS

<PageTitle>Anki Deck Generator</PageTitle>

<span>@_errorMessage</span>
<br />

@switch (_homeView)
{
    case HomeView.FreshNav:
        {
            <div>Do you have a .apkg file already you would like to update?</div>
            <MudButton @onclick="ReadyToUpload">Yes</MudButton>
            <MudButton @onclick="@ReadyToSelect">No</MudButton>
        }
        break;
    case HomeView.ReadyToUpload:
        {
            <InputFile OnChange="LoadFile" accept=".apkg" />
        }
        break;
    case HomeView.Selection:
        {
            <style>
                .mud-table-cell-custom-group {
                    font-weight: 500;
                    width: 95%;
                }

                .mud-table-cell-custom-group-footer {
                    padding-bottom: 50px;
                    text-align: right;
                }
            </style>

            <!-- BIG warning -->
            <h3>Options:</h3>
            <MudCheckBox @bind-Value="_ignoreProperNouns">Ignore proper nouns</MudCheckBox>
            <MudCheckBox @bind-Value="_ignoreAramaic">Ignore Aramaic words</MudCheckBox>
            
            <!-- warning -->
            <MudCheckBox @bind-Value="_backfillOldChapters">Generate missing words from old chapters (only matters if using looser filters than when those chapters were generated)</MudCheckBox>
            <MudNumericField @bind-Value="_minimumWordOccurrence" Label="Filter out words that occur fewer than this many times" Variant="Variant.Text" Min="0" Max="11871" />
            <MudNumericField @bind-Value="_maximumWordOccurrence" Label="Filter out words that occur more than this many times" Variant="Variant.Text" Min="1" Max="11871" />

            <br />

            <MudTable @ref="_mudTable" Hover="true" Breakpoint="Breakpoint.Sm"
                      Items="@GetSelectableChapters()"
                      Virtualize="false"
                      GroupBy="@_groupDefinition"
                      GroupHeaderStyle="background-color:var(--mud-palette-background-gray)"
                      Dense="true"
                      MultiSelection="true">
                <ColGroup>
                    <col style="width: 60px;" />
                    <col style="width: 60px;" />
                </ColGroup>
                <HeaderContent>
                    <MudTh style="width: 60px;"></MudTh>
                </HeaderContent>
                <GroupHeaderTemplate>
                    <MudTh Class="mud-table-cell-custom-group">@(context.Key)</MudTh>
                </GroupHeaderTemplate>
                <RowTemplate>
                    <MudTd>@context.ChapterNumber</MudTd>
                </RowTemplate>
            </MudTable>
            
            <br />
            <br />
            
            <MudButton Color="Color.Primary" @onclick="GenerateDeck">Generate Deck</MudButton>
        }
        break;
    case HomeView.GeneratingDeck:
        {
            <div>
                @foreach(var log in Logs)
                {
                    @log
                    <br />
                }
            </div>
        }
        break;
    case HomeView.DownloadDeck:
        {
            <MudButton @onclick="DownloadFileFromStream" >
                Download New Collection
            </MudButton>
        }
        break;
}

<script>
    window.downloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
    }
</script>

@code {
    private HomeView _homeView = HomeView.FreshNav;
    private string? _errorMessage;
    private List<string> Logs { get; } = new();
    
    private static readonly long HebrewNoteTypeId = 1734550203314;
    private static readonly long AramaicNoteTypeId = 1734550280545;
    private readonly string _preferencesJsonPath = "../HebrewAnki.Data/json metadata/preferences.json";

    private readonly bool _updateExistingNotes = false;

    private bool _ignoreProperNouns = false;
    private bool _ignoreAramaic = false;
    private bool _backfillOldChapters = false;
    private int _minimumWordOccurrence = 0;
    private int _maximumWordOccurrence = 11871;

    private AnkiCollection _uploadedAnkiCollection = null;
    private List<Chapter> _chaptersToSkip = new();
    private List<(string, string)> _wordsToSkip = new();
    private MudTable<Chapter> _mudTable;
    private TableGroupDefinition<Chapter> _groupDefinition = new()
    {
        Indentation = true,
        Expandable = true,
        IsInitiallyExpanded = false,
        Selector = (e) => e.Book
    };

    private byte[] _newCollectionFile = [0];
    
    private void Log(string log)
    {
        Logs.Insert(0, $"{DateTime.Now}: {log}");
        StateHasChanged();
    }

    private void ClearLogs()
    {
        Logs.RemoveAll(x => true);
    }
    
    private async Task LoadFile(InputFileChangeEventArgs e)
    {
        AnkiCollection uploadedAnkiCollection = null;
        
        try
        {
            using var ms = new MemoryStream();
            await e.File.OpenReadStream(200000000000).CopyToAsync(ms);
            uploadedAnkiCollection = await AnkiFileReader.ReadFromStreamAsync(ms);
        }
        catch (Exception ex)
        {
            _errorMessage = "Something went wrong with reading the .apkg file.";
        }

        _uploadedAnkiCollection = uploadedAnkiCollection;
        
        SetChaptersAndWordsToSkip(uploadedAnkiCollection);

        _homeView = HomeView.Selection;
    }

    private void SetChaptersAndWordsToSkip(AnkiCollection uploadedCollection)
    {
        foreach (var deck in uploadedCollection.Decks)
        {
            // root level deck or deck for entire book
            if (!int.TryParse(deck.Name.Last().ToString(), out _))
                continue;
            
            var bookName = deck.Name.Substring(deck.Name.IndexOf("::") + 2);
            bookName = bookName.Substring(0, bookName.IndexOf("::"));

            var chapterNumber = deck.Name.Substring(
                deck.Name.LastIndexOf(" ") + 1,
                deck.Name.Length - deck.Name.LastIndexOf(" ") - 1);
            
            _chaptersToSkip.Add(new()
            {
                Book = bookName,
                ChapterNumber = Int32.Parse(chapterNumber)
            });

            if (!_updateExistingNotes)
                foreach (var note in deck.Cards.Select(c => c.Note))
                {
                    if (note.NoteTypeId == AramaicNoteTypeId)
                        _ = 1;
                    var word = HebrewStringHelper.CleanAndNormalize(note.Fields[0]);
                    var langCode = note.NoteTypeId == HebrewNoteTypeId
                        ? "heb"
                        : "arc";

                    if (!_wordsToSkip.Any(w => w.Item1 == word && w.Item2 == langCode))
                        _wordsToSkip.Add(new ValueTuple<string, string>(word, langCode));
                }
        }
    }

    private List<Chapter> GetSelectableChapters()
    {
        return BookData.GetAllChapters()
            .Where(x => !_chaptersToSkip.Any(s => s.Book == x.Book && s.ChapterNumber == x.ChapterNumber))
            .ToList();
    }

    private void ReadyToUpload()
    {
        _homeView = HomeView.ReadyToUpload;
    }

    private void ReadyToSelect()
    {
        _homeView = HomeView.Selection;
    }

    private async Task GenerateDeck()
    {
        if (!_backfillOldChapters && (!_mudTable.SelectedItems?.Any() ?? false))
        {
            _errorMessage = "No chapters were selected.";
            return;
        }

        _errorMessage = null;
        
        var selectedChapters = _mudTable.SelectedItems!.ToList();
        _homeView = HomeView.GeneratingDeck;
        StateHasChanged();
        await Task.Yield();
        
        ClearLogs();
        var deckBuilderOptions = new DeckBuilderOptions();
        Log("Parsing the lexical index");
        deckBuilderOptions.LexicalIndexEntries = LexicalIndexParser.ParseLexicalIndex("../HebrewAnki.Data/lexicon/LexicalIndex.xml");
        Log("Parsing the BDB");
        deckBuilderOptions.BdbEntries = BdbParser.ParseBdb("../HebrewAnki.Data/lexicon/bdb.xml");
        Log("Parsing the WLC text");
        deckBuilderOptions.WlcBooks = WlcParser.ParseWlcBooks("../HebrewAnki.Data/wlc/");
        deckBuilderOptions.GlobalDeckNamePrefix = "Hebrew/Aramaic Vocab";
        deckBuilderOptions.IgnoreProperNouns = _ignoreProperNouns;
        deckBuilderOptions.IgnoreAramaic = _ignoreAramaic;
        deckBuilderOptions.MinimumNumberOfOccurrences = _minimumWordOccurrence;
        deckBuilderOptions.MaximumNumberOfOccurrences = _maximumWordOccurrence;

        SavePreferences();
        
        var deckScope = DeckScope.Chapter;
        if (_backfillOldChapters)
            selectedChapters.AddRange(_chaptersToSkip);
        
        Log("Creating notes/cards for your selected chapters. This may take a while...");
        var decks = new DeckBuilder(Log, deckBuilderOptions).Build(selectedChapters, _wordsToSkip, deckScope);
        AnkiCollection rootAnkiCollection = null;
        if (_updateExistingNotes)
            rootAnkiCollection = _uploadedAnkiCollection;
        var newCollection = CollectionBuilder.Build(decks, rootAnkiCollection);

        Log("Creating the download file");
        using var ms = new MemoryStream();
        await AnkiFileWriter.WriteToStreamAsync(ms, newCollection);
        _newCollectionFile = ms.ToArray();
        
        _homeView = HomeView.DownloadDeck;
        StateHasChanged();
    }

    private async Task DownloadFileFromStream()
    {
        using var stream = new MemoryStream(_newCollectionFile);
        var fileName = $"Hebrew/Aramaic Vocab - {DateTime.Now}.apkg";

        using var streamRef = new DotNetStreamReference(stream: stream);

        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    private void SavePreferences()
    {
        var preferences = new Preferences
        {
            IgnoreProperNouns = _ignoreProperNouns,
            IgnoreAramaic = _ignoreAramaic,
            MinimumNumberOfOccurrences = _minimumWordOccurrence,
            MaximumNumberOfOccurrences = _maximumWordOccurrence,
            BackFillOldChapters = _backfillOldChapters
        };
        
        var json = JsonSerializer.Serialize(preferences);
        File.Delete(_preferencesJsonPath);
        File.WriteAllText(_preferencesJsonPath, json);
    }

    private void LoadPreferences()
    {
        var json = File.ReadAllText(_preferencesJsonPath);
        var preferences = JsonSerializer.Deserialize<Preferences>(json);

        _ignoreProperNouns = preferences.IgnoreProperNouns;
        _ignoreAramaic = preferences.IgnoreAramaic;
        _minimumWordOccurrence = preferences.MinimumNumberOfOccurrences;
        _maximumWordOccurrence = preferences.MaximumNumberOfOccurrences;
        _backfillOldChapters = preferences.BackFillOldChapters;
    }
    
    protected override async Task OnInitializedAsync()
    {
        LoadPreferences();
    }
}