@page "/"
@using AnkiNet
@using HebrewAnki.Console
@using HebrewAnki.Console.Enums
@using HebrewAnki.Data.XmlParsers
@inject IJSRuntime JS

<PageTitle>Anki Deck Generator</PageTitle>

<span>@_errorMessage</span>
<br />

@switch (_homeView)
{
    case HomeView.FreshNav:
        {
            <div>Do you have a .apkg file already you would like to update?</div>
            <MudButton @onclick="ReadyToUpload">Yes</MudButton>
            <MudButton @onclick="@ReadyToSelect">No</MudButton>
        }
        break;
    case HomeView.ReadyToUpload:
        {
            <InputFile OnChange="LoadFile" accept=".apkg" />
        }
        break;
    case HomeView.Selection:
        {
            <style>
                .mud-table-cell-custom-group {
                    font-weight: 500;
                    width: 95%;
                }

                .mud-table-cell-custom-group-footer {
                    padding-bottom: 50px;
                    text-align: right;
                }
            </style>

            <MudTable @ref="_mudTable "Hover="true" Breakpoint="Breakpoint.Sm"
                      Items="@BookData.GetAllChapters()"
                      Virtualize="false"
                      GroupBy="@_groupDefinition"
                      GroupHeaderStyle="background-color:var(--mud-palette-background-gray)"
                      Dense="true"
                      MultiSelection="true">
                <ColGroup>
                    <col style="width: 60px;" />
                    <col style="width: 60px;" />
                </ColGroup>
                <HeaderContent>
                    <MudTh style="width: 60px;"></MudTh>
                </HeaderContent>
                <GroupHeaderTemplate>
                    <MudTh Class="mud-table-cell-custom-group">@(context.Key)</MudTh>
                </GroupHeaderTemplate>
                <RowTemplate>
                    <MudTd>@context.ChapterNumber</MudTd>
                </RowTemplate>
            </MudTable>
            
            <MudButton @onclick="GenerateDeck">Generate Deck</MudButton>
        }
        break;
    case HomeView.GeneratingDeck:
        {
            <div>
                @foreach(var log in Logs)
                {
                    @log
                    <br />
                }
            </div>
        }
        break;
    case HomeView.DownloadDeck:
        {
            <MudButton @onclick="DownloadFileFromStream" >
                Download New Collection
            </MudButton>
        }
        break;
}

<script>
    window.downloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
    }
</script>

@code {
    private HomeView _homeView = HomeView.FreshNav;
    private string? _errorMessage;
    private List<string> Logs { get; } = new();

    private List<Chapter> _chaptersToSkip = new();
    private MudTable<Chapter> _mudTable;
    private TableGroupDefinition<Chapter> _groupDefinition = new()
    {
        Indentation = true,
        Expandable = true,
        IsInitiallyExpanded = false,
        Selector = (e) => e.Book
    };

    private byte[] _newCollectionFile = [0];
    
    private void Log(string log)
    {
        Logs.Insert(0, $"{DateTime.Now}: {log}");
        StateHasChanged();
    }

    private void ClearLogs()
    {
        Logs.RemoveAll(x => true);
    }
    
    private async Task LoadFile(InputFileChangeEventArgs e)
    {
        try
        {
            using MemoryStream ms = new MemoryStream();
            await e.File.OpenReadStream(200000000000).CopyToAsync(ms);
            var existingAnkiCollection = await AnkiFileReader.ReadFromStreamAsync(ms);
            
            //TODO: populate chapters to skip
        }
        catch (Exception ex)
        {
            _errorMessage = "Something went wrong with reading the .apkg file.";
        }
    }

    private void ReadyToUpload()
    {
        _homeView = HomeView.ReadyToUpload;
    }

    private void ReadyToSelect()
    {
        _homeView = HomeView.Selection;
    }

    private async Task GenerateDeck()
    {
        if (!_mudTable.SelectedItems?.Any() ?? false)
        {
            _errorMessage = "No chapters were selected.";
            return;
        }

        _errorMessage = null;
        
        var selectedChapters = _mudTable.SelectedItems!.ToList();
        _homeView = HomeView.GeneratingDeck;
        StateHasChanged();
        
        ClearLogs();
        Log("Parsing the lexical index");
        var lexicalIndexEntries = LexicalIndexParser.ParseLexicalIndex("../HebrewAnki.Data/lexicon/LexicalIndex.xml");
        Log("Parsing the BDB");
        var bdbEntries = BdbParser.ParseBdb("../HebrewAnki.Data/lexicon/bdb.xml");
        Log("Parsing the WLC text");
        var wlcBooks = WlcParser.ParseWlcBooks("../HebrewAnki.Data/wlc/");
        Log("Parsing the OHSM entries");
        var oshmEntries = OshmParser.ParseOshmEntries("../HebrewAnki.Data/lexicon/Oshm.xml");
        
        var deckScope = DeckScope.Chapter;
        var globalDeckNamePrefix = "12/18/24: Hebrew/Aramaic Vocab";
        Log("Creating notes/cards for your selected chapters. This may take a while...");
        var decks = new DeckBuilder(Log, lexicalIndexEntries, wlcBooks, bdbEntries, oshmEntries, globalDeckNamePrefix).Build(selectedChapters, _chaptersToSkip, deckScope);
        var newCollection = CollectionBuilder.Build(decks);

        Log("Creating the download file");
        using MemoryStream ms = new MemoryStream();
        await AnkiFileWriter.WriteToStreamAsync(ms, newCollection);
        _newCollectionFile = ms.ToArray();
        
        _homeView = HomeView.DownloadDeck;
        StateHasChanged();
    }

    private async Task DownloadFileFromStream()
    {
        using var stream = new MemoryStream(_newCollectionFile);
        var fileName = $"12/18/24: Hebrew/Aramaic Vocab - {DateTime.Now}";

        using var streamRef = new DotNetStreamReference(stream: stream);

        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }
}