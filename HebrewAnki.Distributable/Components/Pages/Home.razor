@page "/"
@using System.Text
@using System.Text.Json
@using AnkiNet
@using HebrewAnki
@using HebrewAnki.Enums
@using HebrewAnki.Data
@using HebrewAnki.Data.Models
@using HebrewAnki.Data.XmlParsers
@using MudBlazor
@inject IJSRuntime JS

<PageTitle>Anki Deck Generator</PageTitle>

<h1>ALWAYS back up your collection before making any modifications to it.</h1>
<span>@_errorMessage</span>
<br />

@switch (_homeView)
{
    case HomeView.FreshNav:
        <div>Do you have a .apkg file already you would like to update?</div>
        <MudButton @onclick="ReadyToUpload">Yes</MudButton>
        <MudButton @onclick="ReadyToSelect">No</MudButton>
        break;
    case HomeView.ReadyToUpload:
        <InputFile OnChange="LoadFile" accept=".apkg" />
        break;
    case HomeView.Selection:
        <style>
            .mud-table-cell-custom-group {
                font-weight: 500;
                width: 95%;
            }
            .mud-table-cell-custom-group-footer {
                padding-bottom: 50px;
                text-align: right;
            }
        </style>
        <h3>Options:</h3>
        <MudCheckBox @bind-Value="_ignoreProperNouns">Ignore proper nouns</MudCheckBox>
        <MudCheckBox @bind-Value="_ignoreAramaic">Ignore Aramaic words</MudCheckBox>
        <MudCheckBox @bind-Value="_backfillOldChapters">Generate missing words from old chapters</MudCheckBox>
        <MudNumericField @bind-Value="_minimumWordOccurrence" Label="Filter out words that occur fewer than this many times" Variant="Variant.Text" Min="0" Max="11871" />
        <MudNumericField @bind-Value="_maximumWordOccurrence" Label="Filter out words that occur more than this many times" Variant="Variant.Text" Min="1" Max="11871" />
        <br />
        @if (GetSelectableChapters().Any())
        {
            <MudTable @ref="_mudTable" Hover="true" Breakpoint="Breakpoint.Sm"
                      Items="@GetSelectableChapters()"
                      Virtualize="false"
                      GroupBy="@_groupDefinition"
                      GroupHeaderStyle="background-color:var(--mud-palette-background-gray)"
                      Dense="true"
                      MultiSelection="true">
                <ColGroup>
                    <col style="width: 60px;" />
                    <col style="width: 60px;" />
                </ColGroup>
                <HeaderContent>
                    <MudTh style="width: 60px;"></MudTh>
                </HeaderContent>
                <GroupHeaderTemplate>
                    <MudTh Class="mud-table-cell-custom-group">@(context.Key)</MudTh>
                </GroupHeaderTemplate>
                <RowTemplate>
                    <MudTd>@context.ChapterNumber</MudTd>
                </RowTemplate>
            </MudTable>
        }
        else
        {
            <div>All chapters are already included in the uploaded collection.</div>
        }
        <br /><br />
        <MudButton Color="Color.Primary" @onclick="GenerateDeck">Generate Deck</MudButton>
        break;
    case HomeView.GeneratingDeck:
        <div>
            @foreach (var log in Logs)
            {
                @log
                <br />
            }
        </div>
        break;
    case HomeView.DownloadDeck:
        <MudButton @onclick="DownloadFileFromStream">Download New Collection</MudButton>
        break;
}

@code {
    private HomeView _homeView = HomeView.FreshNav;
    private string? _errorMessage;
    private List<string> Logs { get; } = new();
    private readonly string _preferencesJsonPath = $"{AppContext.BaseDirectory}/Data/json metadata/preferences.json";
    private readonly bool _updateExistingNotes = false;
    private bool _ignoreProperNouns = false;
    private bool _ignoreAramaic = false;
    private bool _backfillOldChapters = false;
    private int _minimumWordOccurrence = 0;
    private int _maximumWordOccurrence = 11871;
    private AnkiCollection _uploadedAnkiCollection;
    private List<Chapter> _chaptersToSkip = new();
    private List<(string, string)> _wordsToSkip = new();
    private MudTable<Chapter> _mudTable;
    private TableGroupDefinition<Chapter> _groupDefinition = new()
    {
        Indentation = true,
        Expandable = true,
        IsInitiallyExpanded = false,
        Selector = (e) => e.Book
    };
    private byte[] _newCollectionFile = Array.Empty<byte>();

    private async Task Log(string log)
    {
        await InvokeAsync(() =>
        {
            Logs.Insert(0, $"{DateTime.Now}: {log}");
            StateHasChanged();
        });
    }

    private void ClearLogs()
    {
        Logs.Clear();
    }

    private async Task LoadFile(InputFileChangeEventArgs e)
    {
        AnkiCollection? uploadedAnkiCollection = null;
        try
        {
            using var ms = new MemoryStream();
            await e.File.OpenReadStream(50 * 1024 * 1024).CopyToAsync(ms); // 50MB limit
            ms.Position = 0;
            uploadedAnkiCollection = await AnkiFileReader.ReadFromStreamAsync(ms);
        }
        catch (Exception ex)
        {
            _errorMessage = $"Error reading .apkg file: {ex.Message}";
            Log(_errorMessage);
        }

        _uploadedAnkiCollection = uploadedAnkiCollection;

        SetChaptersAndWordsToSkip(uploadedAnkiCollection);

        _homeView = HomeView.Selection;
    }

    private void SetChaptersAndWordsToSkip(AnkiCollection uploadedCollection)
    {
        foreach (var deck in uploadedCollection.Decks)
        {
            // root level deck or deck for entire book
            if (!int.TryParse(deck.Name.Last().ToString(), out _))
                continue;

            var bookName = deck.Name.Substring(deck.Name.IndexOf("::") + 2);
            bookName = bookName.Substring(0, bookName.IndexOf("::"));
            var chapterNumber = deck.Name.Substring(
                deck.Name.LastIndexOf(" ") + 1,
                deck.Name.Length - deck.Name.LastIndexOf(" ") - 1);

            _chaptersToSkip.Add(new()
            {
                Book = bookName,
                ChapterNumber = Int32.Parse(chapterNumber)
            });

            if (!_updateExistingNotes)
                foreach (var note in deck.Cards.Select(c => c.Note))
                {
                    var word = HebrewStringHelper.CleanAndNormalize(note.Fields[0]);
                    var langCode = note.NoteTypeId == AnkiConstants.HebrewNoteTypeId
                        ? "heb"
                        : "arc";
                    if (!_wordsToSkip.Any(w => w.Item1 == word && w.Item2 == langCode))
                        _wordsToSkip.Add((word, langCode));
                }
        }
    }

    private List<Chapter> GetSelectableChapters()
    {
        return BookData.GetAllChapters()
            .Where(x => !_chaptersToSkip.Any(s => s.Book == x.Book && s.ChapterNumber == x.ChapterNumber))
            .ToList();
    }

    private void ReadyToUpload()
    {
        _homeView = HomeView.ReadyToUpload;
    }

    private void ReadyToSelect()
    {
        _homeView = HomeView.Selection;
    }

    private async Task GenerateDeck()
    {
        if (!_backfillOldChapters && (!_mudTable?.SelectedItems?.Any() ?? true))
        {
            _errorMessage = "No chapters were selected.";
            return;
        }

        _errorMessage = null;
        var selectedChapters = _mudTable?.SelectedItems?.ToList() ?? new List<Chapter>();
        _homeView = HomeView.GeneratingDeck;
        StateHasChanged();
        await Task.Delay(1); // Ensure UI update

        ClearLogs();
        var deckBuilderOptions = new DeckBuilderOptions();
        try
        {
            Log("Parsing the lexical index");
            deckBuilderOptions.LexicalIndexEntries = await Task.Run(() => LexicalIndexParser.ParseLexicalIndex());
            StateHasChanged(); // Update UI after parsing
            await Task.Delay(1);

            Log("Parsing the BDB");
            deckBuilderOptions.BdbEntries = await Task.Run(() => BdbParser.ParseBdb());
            StateHasChanged(); // Update UI after parsing
            await Task.Delay(1);

            Log("Parsing the WLC text");
            deckBuilderOptions.WlcBooks = await Task.Run(() => WlcParser.ParseWlcBooks());
            StateHasChanged(); // Update UI after parsing
            await Task.Delay(1);
        }
        catch (Exception ex)
        {
            _errorMessage = $"Error parsing data files: {ex.Message}";
            Log(_errorMessage);
            StateHasChanged();
            return;
        }

        deckBuilderOptions.GlobalDeckNamePrefix = "Hebrew/Aramaic Vocab";
        deckBuilderOptions.IgnoreProperNouns = _ignoreProperNouns;
        deckBuilderOptions.IgnoreAramaic = _ignoreAramaic;
        deckBuilderOptions.MinimumNumberOfOccurrences = _minimumWordOccurrence;
        deckBuilderOptions.MaximumNumberOfOccurrences = _maximumWordOccurrence;

        SavePreferences();
        StateHasChanged();
        await Task.Delay(1);

        var deckScope = DeckScope.Chapter;
        if (_backfillOldChapters)
            selectedChapters.AddRange(_chaptersToSkip);

        Log("Creating notes/cards for your selected chapters. This may take a while...");
        StateHasChanged();
        await Task.Delay(1);

        try
        {
            var decks = await Task.Run(() => new DeckBuilder(Log, deckBuilderOptions).Build(selectedChapters, _wordsToSkip, deckScope));
            AnkiCollection? rootAnkiCollection = _updateExistingNotes ? _uploadedAnkiCollection : null;

            Log("Creating the download file");
            StateHasChanged();
            await Task.Delay(1);

            var newCollection = await Task.Run(() => CollectionBuilder.Build(decks, rootAnkiCollection));
            using var ms = new MemoryStream();
            await AnkiFileWriter.WriteToStreamAsync(ms, newCollection);
            _newCollectionFile = ms.ToArray();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Error generating deck: {ex.Message}";
            Log(_errorMessage);
            StateHasChanged();
            return;
        }

        _homeView = HomeView.DownloadDeck;
        StateHasChanged();
    }

    private async Task DownloadFileFromStream()
    {
        if (_newCollectionFile == null || _newCollectionFile.Length == 0)
        {
            _errorMessage = "No deck file available for download.";
            Log(_errorMessage);
            return;
        }

        try
        {
            using var stream = new MemoryStream(_newCollectionFile);
            var fileName = $"HebrewAramaicVocab_{DateTime.Now:yyyyMMdd_HHmmss}.apkg";
            using var streamRef = new DotNetStreamReference(stream: stream);
            await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
        }
        catch (Exception ex)
        {
            _errorMessage = $"Error downloading file: {ex.Message}";
            Log(_errorMessage);
        }
    }

    private void SavePreferences()
    {
        var preferences = new Preferences
        {
            IgnoreProperNouns = _ignoreProperNouns,
            IgnoreAramaic = _ignoreAramaic,
            MinimumNumberOfOccurrences = _minimumWordOccurrence,
            MaximumNumberOfOccurrences = _maximumWordOccurrence,
            BackFillOldChapters = _backfillOldChapters
        };

        try
        {
            Directory.CreateDirectory(Path.GetDirectoryName(_preferencesJsonPath)!);
            var json = JsonSerializer.Serialize(preferences);
            File.WriteAllText(_preferencesJsonPath, json);
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to save preferences: {ex.Message}";
            Log(_errorMessage);
        }
    }

    private void LoadPreferences()
    {
        try
        {
            if (File.Exists(_preferencesJsonPath))
            {
                var json = File.ReadAllText(_preferencesJsonPath);
                var preferences = JsonSerializer.Deserialize<Preferences>(json);
                _ignoreProperNouns = preferences!.IgnoreProperNouns;
                _ignoreAramaic = preferences.IgnoreAramaic;
                _minimumWordOccurrence = preferences.MinimumNumberOfOccurrences;
                _maximumWordOccurrence = preferences.MaximumNumberOfOccurrences;
                _backfillOldChapters = preferences.BackFillOldChapters;
            }
            else
            {
                Log("No preferences file found; using defaults.");
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Failed to load preferences: {ex.Message}";
            Log(_errorMessage);
        }
    }

    protected override async Task OnInitializedAsync()
    {
        LoadPreferences();
        await Task.CompletedTask;
    }
}